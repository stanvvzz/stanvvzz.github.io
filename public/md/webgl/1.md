# webgl点击绘制点

所有者: Stan

1. 创建画布
2. 构建webgl程序
3. 获取点击位置，push进数据
4. 通过数组渲染点
5. 注意： `canvas.toDataURL("image/png")` 只会导出当前canvas上的内容。所以在每次点击之后进行设置：`downloadLink.href = canvas.toDataURL("image/png");`

```glsl
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta
            name="viewport"
            content="width=device-width, initial-scale=1.0"
        />
        <title>Document</title>
    </head>
    <body>
        <canvas
            id="webgl-canvas"
            width="400"
            height="400"
            style="border: 1px solid #ccc"
        ></canvas>

        <script>
            const canvas = document.getElementById("webgl-canvas");
            const gl = canvas.getContext("webgl");

            const vertexShaderSource = `
				attribute vec4 a_Position;
				void main(){
					gl_Position = a_Position;
					gl_PointSize = 10.0;
				}
			`;

            const fragmentShaderSource = `
				void main(){
					gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
				}
			`;

            function createShader(gl, type, source) {
                // 创建着色器对象
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                return shader;
            }

            const vertexShader = createShader(
                gl,
                gl.VERTEX_SHADER,
                vertexShaderSource
            );
            const fragmentShader = createShader(
                gl,
                gl.FRAGMENT_SHADER,
                fragmentShaderSource
            );

            // 创建程序对象
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            gl.useProgram(program);

            const a_Position = gl.getAttribLocation(program, "a_Position");

            // 设置背景白色
            gl.clearColor(1.0, 1.0, 1.0, 1.0);
            // 清除颜色缓冲区
            gl.clear(gl.COLOR_BUFFER_BIT);

            const points = [];

            document.addEventListener("click", (event) => {
                // 获取点击位置
                const rect = canvas.getBoundingClientRect();
                const x = ((event.clientX - rect.left) / canvas.width) * 2 - 1;
                const y = -((event.clientY - rect.top) / canvas.height) * 2 + 1;

                // 存储点击的点
                points.push(x, y);

                // 创建缓冲区
                // 在GPU上存储点数据
                const buffer = gl.createBuffer();
                // 绑定缓冲区对象到目标
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                // 将点数据传输到缓冲区
                // gl.STATIC_DRAW：表示数据不会改变
                gl.bufferData(
                    gl.ARRAY_BUFFER,
                    new Float32Array(points),
                    gl.STATIC_DRAW
                );

                // 绑定缓冲区到着色器属性
                // a_Position：顶点位置属性
                // 2：每个顶点有两个分量（x, y）
                // gl.FLOAT：数据类型为浮点数
                // false：不需要归一化
                // 0：每个顶点之间没有间隔
                gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(a_Position);

                gl.clear(gl.COLOR_BUFFER_BIT);

                gl.drawArrays(gl.POINTS, 0, points.length / 2);

                downloadLink.href = canvas.toDataURL("image/png");
            });

            // 下载
            const downloadLink = document.createElement("a");
            downloadLink.download = "webgl-canvas.png";
            downloadLink.innerText = "下载";
            document.body.appendChild(downloadLink);
        </script>
    </body>
</html>

```

![webgl-canvas (1).png](/public/md/webgl/image/webgl-canvas.png)