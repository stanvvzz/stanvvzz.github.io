# C++11/14/17 现代特性指南

现代 C++（C++11 及其后续版本）引入了许多强大的特性，极大地改善了 C++ 的编程体验。本文将深入讲解这些重要特性。

## 自动类型推导

### auto 关键字

`auto` 让编译器自动推导变量类型：

```cpp
#include <vector>
#include <map>

int main() {
    // 基本类型推导
    auto x = 42;        // int
    auto y = 3.14;      // double
    auto z = "hello";   // const char*
    
    // 复杂类型推导
    std::vector<int> vec = {1, 2, 3, 4, 5};
    auto it = vec.begin();  // std::vector<int>::iterator
    
    // 避免冗长的类型名
    std::map<std::string, std::vector<int>> data;
    auto iter = data.find("key");  // 而不是 std::map<std::string, std::vector<int>>::iterator
    
    return 0;
}
```

### decltype

`decltype` 推导表达式的类型：

```cpp
int x = 42;
decltype(x) y = x;  // y 的类型是 int

template<typename T, typename U>
auto add(T t, U u) -> decltype(t + u) {
    return t + u;
}
```

## 智能指针

智能指针自动管理内存，避免内存泄漏：

### unique_ptr

```cpp
#include <memory>

class Resource {
public:
    Resource() { std::cout << "Resource created\n"; }
    ~Resource() { std::cout << "Resource destroyed\n"; }
    void use() { std::cout << "Using resource\n"; }
};

int main() {
    // 创建 unique_ptr
    auto ptr = std::make_unique<Resource>();
    ptr->use();
    
    // 移动语义
    auto ptr2 = std::move(ptr);  // ptr 现在为空
    
    // 自动释放资源
    return 0;  // Resource 在这里被自动销毁
}
```

### shared_ptr

```cpp
#include <memory>
#include <vector>

int main() {
    auto shared = std::make_shared<Resource>();
    std::vector<std::shared_ptr<Resource>> vec;
    
    vec.push_back(shared);
    vec.push_back(shared);
    
    std::cout << "引用计数: " << shared.use_count() << std::endl;  // 输出: 3
    
    return 0;
}
```

## 移动语义和右值引用

移动语义避免不必要的拷贝操作：

```cpp
#include <vector>
#include <string>

class MyString {
private:
    char* data;
    size_t size;

public:
    // 构造函数
    MyString(const char* str) {
        size = strlen(str);
        data = new char[size + 1];
        strcpy(data, str);
    }
    
    // 拷贝构造函数
    MyString(const MyString& other) : size(other.size) {
        data = new char[size + 1];
        strcpy(data, other.data);
    }
    
    // 移动构造函数
    MyString(MyString&& other) noexcept : data(other.data), size(other.size) {
        other.data = nullptr;
        other.size = 0;
    }
    
    // 移动赋值运算符
    MyString& operator=(MyString&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = other.data;
            size = other.size;
            other.data = nullptr;
            other.size = 0;
        }
        return *this;
    }
    
    ~MyString() {
        delete[] data;
    }
};

// 使用移动语义
std::vector<MyString> createStrings() {
    std::vector<MyString> vec;
    vec.emplace_back("Hello");      // 直接构造，避免拷贝
    vec.push_back(MyString("World")); // 移动构造
    return vec;  // 返回值优化（RVO）
}
```

## Lambda 表达式

Lambda 提供了简洁的匿名函数语法：

```cpp
#include <algorithm>
#include <vector>
#include <functional>

int main() {
    std::vector<int> numbers = {5, 2, 8, 1, 9, 3};
    
    // 基本 lambda
    auto square = [](int x) { return x * x; };
    
    // 捕获外部变量
    int factor = 2;
    auto multiply = [factor](int x) { return x * factor; };
    
    // 按引用捕获
    auto increment = [&factor]() { factor++; };
    
    // 捕获所有变量
    auto lambda1 = [=](int x) { return x + factor; };  // 按值捕获所有
    auto lambda2 = [&](int x) { return x + factor; };  // 按引用捕获所有
    
    // 在算法中使用
    std::sort(numbers.begin(), numbers.end(), [](int a, int b) {
        return a > b;  // 降序排序
    });
    
    // 条件查找
    auto it = std::find_if(numbers.begin(), numbers.end(), 
                          [](int x) { return x > 5; });
    
    return 0;
}
```

## 范围循环

简化容器遍历：

```cpp
#include <vector>
#include <map>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};
    
    // 基本范围循环
    for (const auto& item : vec) {
        std::cout << item << " ";
    }
    
    // 修改元素
    for (auto& item : vec) {
        item *= 2;
    }
    
    // 遍历 map
    std::map<std::string, int> data = {
        {"apple", 5},
        {"banana", 3},
        {"orange", 7}
    };
    
    for (const auto& [key, value] : data) {  // C++17 结构化绑定
        std::cout << key << ": " << value << std::endl;
    }
    
    return 0;
}
```

## 初始化列表

统一的初始化语法：

```cpp
#include <vector>
#include <map>
#include <string>

class Point {
public:
    double x, y;
    
    // 列表初始化构造函数
    Point(std::initializer_list<double> values) {
        auto it = values.begin();
        x = *it++;
        y = *it;
    }
};

int main() {
    // 基本类型
    int x{42};
    double y{3.14};
    
    // 容器初始化
    std::vector<int> vec{1, 2, 3, 4, 5};
    std::map<std::string, int> map{
        {"one", 1},
        {"two", 2},
        {"three", 3}
    };
    
    // 自定义类型
    Point p{1.0, 2.0};
    
    return 0;
}
```

## 并发支持

C++11 引入了标准的线程库：

```cpp
#include <thread>
#include <mutex>
#include <condition_variable>
#include <future>

std::mutex mtx;
std::condition_variable cv;
bool ready = false;

void worker(int id) {
    std::unique_lock<std::mutex> lock(mtx);
    cv.wait(lock, [] { return ready; });
    
    std::cout << "Worker " << id << " is working\n";
}

int main() {
    // 创建线程
    std::vector<std::thread> workers;
    for (int i = 0; i < 3; ++i) {
        workers.emplace_back(worker, i);
    }
    
    // 使用 future 和 promise
    auto future = std::async(std::launch::async, []() {
        std::this_thread::sleep_for(std::chrono::seconds(1));
        return 42;
    });
    
    // 通知所有线程开始工作
    {
        std::lock_guard<std::mutex> lock(mtx);
        ready = true;
    }
    cv.notify_all();
    
    // 等待异步任务完成
    int result = future.get();
    std::cout << "Async result: " << result << std::endl;
    
    // 等待所有线程完成
    for (auto& t : workers) {
        t.join();
    }
    
    return 0;
}
```

## 小结

现代 C++ 的主要特性：

1. **自动类型推导** - `auto` 和 `decltype`
2. **智能指针** - 自动内存管理
3. **移动语义** - 高效的资源管理
4. **Lambda 表达式** - 函数式编程支持
5. **范围循环** - 简化容器遍历
6. **初始化列表** - 统一的初始化语法
7. **并发支持** - 标准线程库

这些特性让 C++ 代码更加安全、高效和易读。
