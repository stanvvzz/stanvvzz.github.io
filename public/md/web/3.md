# 刮刮乐

所有者: Stan

1. `ctx.save()` `ctx.restore()` 来保存、重制画布状态
2. `destination-out`：仅保留现有画布内容和新形状不重叠的部分

学习自：[https://space.bilibili.com/1028978784](https://space.bilibili.com/1028978784)

```jsx
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8" />
        <meta
            name="viewport"
            content="width=device-width,user-scalable=no"
        />
        <title>刮刮乐</title>
        <style>
            body {
                margin: 0;
                overflow: hidden;
            }
            #canvas {
                background-image: url("./image/1.jpg");
                background-size: cover;
                background-position: center;
                background-repeat: no-repeat;
            }
        </style>
    </head>
    <body>
        <canvas id="canvas"></canvas>
        <script>
            const canvas = document.getElementById("canvas");
            const ctx = canvas.getContext("2d");

            const [width, height] = [400, 400];
            canvas.width = 400;
            canvas.height = 400;

            ctx.fillStyle = "#808080";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = "white";

            // 水平居中
            ctx.textAlign = "center";
            // 垂直居中
            ctx.textBaseline = "middle";

            ctx.font = "14px Arial";
            ctx.fillText("用鼠标刮开涂层", canvas.width / 2, canvas.height / 2);

            class Line {
                constructor(ctx) {
                    this.ctx = ctx;
                    this.drawing = false;
                }
                moveTo(x, y) {
                    const { ctx } = this;
                    this.drawing = true;
                    ctx.save();
                    ctx.lineWidth = 30;
                    // destination-out：仅保留现有画布内容和新形状不重叠的部分
                    ctx.globalCompositeOperation = "destination-out";
                    ctx.moveTo(x, y);
                }
                lineTo(x, y) {
                    if (!this.drawing) {
                        return;
                    }
                    const { ctx } = this;
                    ctx.lineTo(x, y);
                    ctx.stroke();
                }
                restore() {
                    if (!this.drawing) {
                        return;
                    }
                    const { ctx } = this;
                    ctx.restore();
                    this.drawing = false;
                }
            }

            const line = new Line(ctx);

            canvas.addEventListener("mousedown", (event) => {
                if (event.buttons === 1) {
                    //获取鼠标位置
                    const { x, y } = getMousePos(event);
                    //绘制起点
                    line.moveTo(x, y);
                }
            });

            canvas.addEventListener("mousemove", (event) => {
                //鼠标左键按下且处于绘图状态
                if (event.buttons === 1) {
                    //获取鼠标位置
                    const { x, y } = getMousePos(event);
                    //绘制下一个点
                    line.lineTo(x, y);
                }
            });

            canvas.addEventListener("mouseup", (event) => {
                //鼠标左键按下
                if (event.buttons === 1) {
                    //状态还原
                    line.restore();
                }
            });

            //获取鼠标在canvas中的位置
            function getMousePos(event) {
                const { clientX, clientY } = event;

                const { top, left } = canvas.getBoundingClientRect();

                //计算鼠标在canvas 中的位置
                const x = clientX - left;
                const y = clientY - top;
                return { x, y };
            }
        </script>
    </body>
</html>

```

![scratch-lottery.png](/public/md/web/image/1752760989941.jpg)