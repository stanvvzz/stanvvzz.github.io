# webgl简单旋转

所有者: Stan

右手坐标系中：

- 当物体绕z 轴，从x轴正半轴向y轴正半轴逆时针旋转时，是正向旋转，反之为负。
- 当物体绕x 轴，从y轴正半轴向z轴正半轴逆时针旋转时，是正向旋转，反之为负。
- 当物体绕y 轴，从z轴正半轴向x轴正半轴逆时针旋转时，是正向旋转，反之为负。

旋转公式推导：

![E447C3CE9D6F725D4616BDB7B3376885.jpg](/md/webgl/image/3.1.jpg)

```jsx
<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8" />
        <meta
            name="viewport"
            content="width=device-width, initial-scale=1.0"
        />
        <title></title>
        <style>
            input[type="range"] {
                width: 250px;
            }
            #angle-value {
                margin-left: 10px;
                font-weight: bold;
                min-width: 40px;
            }
        </style>
    </head>
    <body>
        <canvas
            id="webgl-canvas"
            width="400"
            height="400"
            style="border: 1px solid #ccc"
        ></canvas>

        <div class="controls">
            <label for="rotation-slider">旋转角度:</label>
            <input
                type="range"
                id="rotation-slider"
                min="0"
                max="360"
                value="60"
            />
            <span id="angle-value">60°</span>
        </div>

        <script>
            const canvas = document.getElementById("webgl-canvas");
            const gl = canvas.getContext("webgl");
            if (!gl) {
                alert("您的浏览器不支持 WebGL");
            }

            const vsSource = `
                attribute vec4 a_Position;
                uniform float u_Radian;

                void main() {

                    float s = sin(u_Radian);
                    float c = cos(u_Radian);

                    gl_Position.x = a_Position.x * c - a_Position.y * s;
                    gl_Position.y = a_Position.x * s + a_Position.y * c;
                    gl_Position.z = a_Position.z;
                    gl_Position.w = 1.0;
                }
            `;

            const fsSource = `
                precision mediump float;
                void main() {
                    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
                }
            `;

            function createShader(gl, type, source) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error(
                        "着色器编译失败:",
                        gl.getShaderInfoLog(shader)
                    );
                    gl.deleteShader(shader);
                    return null;
                }
                return shader;
            }

            function createProgram(gl, vsSource, fsSource) {
                const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
                const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
                const program = gl.createProgram();
                gl.attachShader(program, vs);
                gl.attachShader(program, fs);
                gl.linkProgram(program);
                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    console.error(
                        "程序链接失败:",
                        gl.getProgramInfoLog(program)
                    );
                    gl.deleteProgram(program);
                    return null;
                }
                return program;
            }

            const program = createProgram(gl, vsSource, fsSource);
            gl.useProgram(program);

            const vertices = new Float32Array([
                0.0,
                0.5, // 顶点1
                -0.5,
                -0.5, // 顶点2
                0.5,
                -0.5, // 顶点3
            ]);
            const vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

            const a_Position = gl.getAttribLocation(program, "a_Position");
            gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(a_Position);

            const u_Radian = gl.getUniformLocation(program, "u_Radian");

            const slider = document.getElementById("rotation-slider");
            const angleValueSpan = document.getElementById("angle-value");

            function drawScene(angle) {
                const radian = (Math.PI * angle) / 180.0;

                gl.uniform1f(u_Radian, radian);

                gl.clearColor(1.0, 1.0, 1.0, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT);

                gl.drawArrays(gl.TRIANGLES, 0, 3);
            }

            slider.addEventListener("input", function () {
                const angle = this.value;
                angleValueSpan.textContent = `${angle}°`;
                drawScene(angle);
            });

            drawScene(slider.value);
        </script>
    </body>
</html>

```

![webgl-rotation.png](/md/webgl/image/webgl-rotation.png)