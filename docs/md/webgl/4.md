# 绘制多线

所有者: Stan

1. `discard` 裁剪片元
2. `gl.STREAM_DRAW`  适配高频率实时数据上传
3. `uniform`  控制绘制点还是绘制线条

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta
            name="viewport"
            content="width=device-width, initial-scale=1.0"
        />
        <title>Document</title>
    </head>
    <body>
        <canvas
            id="webgl-canvas"
            width="400"
            height="400"
            style="border: 1px solid #ccc"
        ></canvas>

        <script>
            const canvas = document.getElementById("webgl-canvas");

            const gl = canvas.getContext("webgl");

            const vertexShaderSource = `
                attribute vec4 a_Position;
                void main() {
                    gl_Position = a_Position;
                    gl_PointSize = 10.0;
                }
            `;

            const fragmentShaderSource = `
				precision mediump float;
				uniform bool u_IsDrawingPoints;

				void main() {
					if (u_IsDrawingPoints) {
						float r = 0.0;
						vec2 cxy = 2.0 * gl_PointCoord - 1.0;
						r = dot(cxy, cxy);
						if(r > 1.0) {
							discard;
						}
					}

					gl_FragColor = vec4(0.0, 0.6, 1.0, 1.0);
				}
			`;

            function createShader(gl, type, source) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error(
                        "着色器编译失败:",
                        gl.getShaderInfoLog(shader)
                    );
                    gl.deleteShader(shader);
                    return null;
                }
                return shader;
            }

            // 创建着色器和程序
            const vertexShader = createShader(
                gl,
                gl.VERTEX_SHADER,
                vertexShaderSource
            );
            const fragmentShader = createShader(
                gl,
                gl.FRAGMENT_SHADER,
                fragmentShaderSource
            );
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error("程序链接失败:", gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                throw new Error("程序链接失败");
            }
            gl.useProgram(program);

            const a_Position = gl.getAttribLocation(program, "a_Position");
            const u_IsDrawingPoints = gl.getUniformLocation(
                program,
                "u_IsDrawingPoints"
            );
            const buffer = gl.createBuffer();

            // 存储线段的起始和结束位置
            const lines = [];
            let currentLine = [];
            let tempPoint = null;
            let drawing = false;

            function getMousePosition(e) {
                const rect = canvas.getBoundingClientRect();
                const x = ((e.clientX - rect.left) / canvas.width) * 2 - 1;
                const y = 1 - ((e.clientY - rect.top) / canvas.height) * 2;
                return [x, y];
            }

            function draw() {
                gl.clearColor(1.0, 1.0, 1.0, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT);

                const drawPrimitive = (lineData, isDrawingPoints) => {
                    if (lineData.length < 1) return;
                    const pointCount = lineData.length;

                    const flatData = new Float32Array(lineData.flat());
                    gl.bufferData(gl.ARRAY_BUFFER, flatData, gl.STREAM_DRAW);
                    gl.vertexAttribPointer(
                        a_Position,
                        2,
                        gl.FLOAT,
                        false,
                        0,
                        0
                    );
                    gl.enableVertexAttribArray(a_Position);

                    // 绘制线条
                    if (pointCount >= 2) {
                        gl.uniform1i(u_IsDrawingPoints, 0);
                        gl.drawArrays(gl.LINE_STRIP, 0, pointCount);
                    }

                    // 绘制圆点
                    gl.uniform1i(u_IsDrawingPoints, 1);
                    gl.drawArrays(gl.POINTS, 0, pointCount);
                };

                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);

                // 先绘制历史线条
                for (const line of lines) {
                    drawPrimitive(line, false);
                }

                // 绘制当前线
                let drawPoints = currentLine.slice();
                if (drawing && tempPoint) {
                    drawPoints.push(tempPoint);
                }

                drawPrimitive(drawPoints, drawing);
            }

            canvas.addEventListener("mousedown", (e) => {
                if (e.button === 0) {
                    const pos = getMousePosition(e);
                    if (!drawing) {
                        currentLine = [pos];
                        drawing = true;
                    } else {
                        currentLine.push(pos);
                    }
                    tempPoint = null;
                    draw();
                }
            });

            canvas.addEventListener("mousemove", (e) => {
                if (drawing) {
                    tempPoint = getMousePosition(e);
                    draw();
                }
            });

            canvas.addEventListener("contextmenu", (e) => {
                e.preventDefault();
                if (drawing) {
                    drawing = false;
                    tempPoint = null;
                    if (currentLine.length >= 2) {
                        lines.push(currentLine.slice());
                    }
                    // 设置当前线为空数组再调用绘制一次
                    currentLine = [];
                    draw();
                }
            });

            // 初始化清屏
            draw();
        </script>
    </body>
</html>

```

![webgl-click-line2 (2).png](/md/webgl/image/6.png)