# 手写Promise

所有者: Stan

一个 Promise 就像一个约定，它有三种状态：

- **Pending** (进行中): 初始状态，既没有成功，也没有失败。
- **Fulfilled** (已成功): 意味着操作成功完成。
- **Rejected** (已失败): 意味着操作失败。

这个状态一旦从 `pending` 改变为 `fulfilled` 或 `rejected`，就再也不会改变

`(*resolve*, *reject*) => {}` 为 executor 执行器

- `resolve()` : 当调用时，Promise 的状态会从 `pending` 变为 `fulfilled` (成功)。
- `reject()`   : 当调用时，Promise 的状态会从 `pending` 变为 `rejected` (失败)。

**`then`**

then是promise的核心方法，负责链接和调度

- **注册回调**: `.then(onFulfilled, onRejected)` 用于注册成功和失败的回调。
- **返回新 Promise**: **关键点**：`.then()` 方法必须返回一个**全新的 Promise** (`promise2`)，这是实现链式调用的基础。
- **异步执行回调**: **关键点**：`onFulfilled` 和 `onRejected` 回调必须是**异步执行**的。代码中使用了 `queueMicrotask()` 来确保这一点。
- **处理不同状态**:
    - 如果调用 `.then` 时 Promise 状态还是 `PENDING`，则将回调存入队列。
    - 如果已经是 `FULFILLED` 或 `REJECTED`，则直接将对应的回调放入微任务队列准备执行。
- **参数穿透**: 如果 `onFulfilled` 或 `onRejected` 不是函数，必须忽略它们，并让值/原因“穿透”到链的下一环。

**`resolvePromise`** 

这是实现链式调用的**最核心、最复杂的逻辑**。它的职责是解析 `.then` 回调的返回值 `x` 与新 Promise `promise2` 之间的关系。

- **防止循环引用**: 如果 `x` 和 `promise2` 是同一个对象，必须抛出 `TypeError`。
- **处理 `thenable` 对象**: **关键点**：如果 `x` 是一个对象或函数（可能是一个 Promise 或其他带有 `then` 方法的对象，即 `thenable`），需要尝试执行它的 `then` 方法来决定 `promise2` 的最终状态。
- **递归解析**: 因为 `thenable` 对象 resolve 的结果可能还是一个 `thenable`，所以这个过程需要递归调用 `resolvePromise` 直到解析出一个普通值为止。
- **处理普通值**: 如果 `x` 是一个普通值，直接用这个值来 `resolve(x)` 新的 `promise2`。

**`MyPromise.all(promises)`**:

- **作用**: 接收一个可迭代对象（如数组），返回一个新 Promise。
- **技术要点**:
    - 只有当所有 `promises` 都成功时，返回的 Promise 才会成功，其值为一个包含所有结果的数组（**顺序与输入一致**）。
    - 只要有一个 `promise` 失败，返回的 Promise 就会**立即失败**，其原因为第一个失败的 Promise 的原因。
    - 需要处理传入的数组中包含非 Promise 值的情况，这时 `MyPromise.resolve` 就派上了用场。

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta
            name="viewport"
            content="width=device-width, initial-scale=1.0"
        />
        <title>MyPromise Implementation</title>
    </head>
    <body>
        <script>
            const PENDING = "pending";
            const FULFILLED = "fulfilled";
            const REJECTED = "rejected";

            /**
             * Promise 解决过程，根据 x 的类型来决定 promise2 的状态
             * @param {MyPromise} promise2 then 方法返回的新 Promise
             * @param {*} x onFulfilled 或 onRejected 的返回值
             * @param {Function} resolve promise2 的 resolve 函数
             * @param {Function} reject promise2 的 reject 函数
             */
            function resolvePromise(promise2, x, resolve, reject) {
                // 1. 防止循环引用
                if (promise2 === x) {
                    // 直接抛出类型错误
                    return reject(
                        new TypeError("Chaining cycle detected for promise")
                    );
                }

                // 2. 判断 x 的类型
                // 只有当 x 是对象或函数时，才可能是 thenable
                if (
                    (typeof x === "object" && x !== null) ||
                    typeof x === "function"
                ) {
                    let called = false; // 防止 thenable 的 resolve/reject 被多次调用
                    try {
                        // 尝试获取 x 的 then 方法
                        const then = x.then;
                        if (typeof then === "function") {
                            // 如果 then 是一个函数，就认为 x 是一个 thenable
                            // 使用 call 来执行 then，并把 this 指向 x
                            then.call(
                                x,
                                // thenable 的第一个成功回调
                                (y) => {
                                    if (called) return;
                                    called = true;
                                    // 递归解析 y，因为 y 也可能是一个 Promise
                                    resolvePromise(
                                        promise2,
                                        y,
                                        resolve,
                                        reject
                                    );
                                },
                                // thenable 的第二个失败回调
                                (r) => {
                                    if (called) return;
                                    called = true;
                                    reject(r);
                                }
                            );
                        } else {
                            // 如果 x.then 不是函数，说明 x 是一个普通对象，直接 resolve
                            resolve(x);
                        }
                    } catch (e) {
                        // 如果取 x.then 或执行 then.call 出错
                        if (called) return;
                        called = true;
                        reject(e);
                    }
                } else {
                    // 3. 如果 x 是一个普通值，直接 resolve
                    resolve(x);
                }
            }

            class MyPromise {
                constructor(executor) {
                    this.status = PENDING;
                    this.value = undefined;
                    this.reason = undefined;

                    this.onFulfilledCallbacks = [];
                    this.onRejectedCallbacks = [];

                    const resolve = (value) => {
                        // 如果 value 是一个 Promise，需要等待它完成
                        if (value instanceof MyPromise) {
                            return value.then(resolve, reject);
                        }

                        if (this.status === PENDING) {
                            this.status = FULFILLED;
                            this.value = value;
                            this.onFulfilledCallbacks.forEach((fn) => fn());
                        }
                    };

                    const reject = (reason) => {
                        if (this.status === PENDING) {
                            this.status = REJECTED;
                            this.reason = reason;
                            this.onRejectedCallbacks.forEach((fn) => fn());
                        }
                    };

                    try {
                        executor(resolve, reject);
                    } catch (error) {
                        reject(error);
                    }
                }

                then(onFulfilled, onRejected) {
                    // 如果 onFulfilled 不是函数，则创建一个函数将值原样返回
                    onFulfilled =
                        typeof onFulfilled === "function"
                            ? onFulfilled
                            : (value) => value;
                    // 如果 onRejected 不是函数，则创建一个函数将错误原样抛出
                    onRejected =
                        typeof onRejected === "function"
                            ? onRejected
                            : (reason) => {
                                  throw reason;
                              };

                    const promise2 = new MyPromise((resolve, reject) => {
                        const fulfilledMicrotask = () => {
                            queueMicrotask(() => {
                                try {
                                    const x = onFulfilled(this.value);
                                    resolvePromise(
                                        promise2,
                                        x,
                                        resolve,
                                        reject
                                    );
                                } catch (error) {
                                    reject(error);
                                }
                            });
                        };

                        const rejectedMicrotask = () => {
                            queueMicrotask(() => {
                                try {
                                    const x = onRejected(this.reason);
                                    // 注意：即使是从 onRejected 返回的，只要没有抛错，新的 promise 也应该被 resolve
                                    resolvePromise(
                                        promise2,
                                        x,
                                        resolve,
                                        reject
                                    );
                                } catch (e) {
                                    reject(e);
                                }
                            });
                        };

                        if (this.status === PENDING) {
                            this.onFulfilledCallbacks.push(fulfilledMicrotask);
                            this.onRejectedCallbacks.push(rejectedMicrotask);
                        } else if (this.status === FULFILLED) {
                            fulfilledMicrotask();
                        } else if (this.status === REJECTED) {
                            rejectedMicrotask();
                        }
                    });

                    return promise2;
                }

                static resolve(value) {
                    if (value instanceof MyPromise) {
                        return value;
                    }
                    return new MyPromise((resolve) => {
                        resolve(value);
                    });
                }

                static all(promises) {
                    return new MyPromise((resolve, reject) => {
                        // 判断 promises 是否为可迭代对象
                        if (typeof promises[Symbol.iterator] !== "function") {
                            return reject(
                                new TypeError("Argument is not iterable")
                            );
                        }

                        const results = [];
                        let resolvedCount = 0;
                        const promisesLength = promises.length;

                        // 如果传入的是空数组，直接 resolve
                        if (promisesLength === 0) {
                            return resolve(results);
                        }

                        promises.forEach((promise, index) => {
                            // 使用 MyPromise.resolve 包装，确保处理非 Promise 值
                            MyPromise.resolve(promise).then(
                                (value) => {
                                    // 保证结果的顺序和传入的 promises 顺序一致
                                    results[index] = value;
                                    resolvedCount++;
                                    // 当所有 promise 都成功时，resolve 结果数组
                                    if (resolvedCount === promisesLength) {
                                        resolve(results);
                                    }
                                },
                                (reason) => {
                                    // 只要有一个 promise 失败，就立即 reject
                                    reject(reason);
                                }
                            );
                        });
                    });
                }
            }
        </script>
    </body>
</html>

```