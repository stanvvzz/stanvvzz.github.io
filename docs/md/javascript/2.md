# 异步编程：Promise 与 async/await

异步编程是 JavaScript 的核心特性之一，本文将深入探讨 Promise 和 async/await 的使用方法和最佳实践。

## Promise 基础

Promise 表示一个异步操作的最终结果：

```javascript
// Promise 的三种状态
const promise = new Promise((resolve, reject) => {
    const success = Math.random() > 0.5;

    setTimeout(() => {
        if (success) {
            resolve("操作成功");
        } else {
            reject(new Error("操作失败"));
        }
    }, 1000);
});

// 使用 Promise
promise
    .then((result) => {
        console.log("成功:", result);
    })
    .catch((error) => {
        console.error("失败:", error.message);
    })
    .finally(() => {
        console.log("无论成功失败都会执行");
    });
```

## Promise 链式调用

避免回调地狱的解决方案：

```javascript
// 传统回调地狱
function callbackHell() {
    getData(function (a) {
        getMoreData(a, function (b) {
            getEvenMoreData(b, function (c) {
                // 嵌套越来越深...
            });
        });
    });
}

// Promise 链式调用
function promiseChain() {
    return getData()
        .then((a) => getMoreData(a))
        .then((b) => getEvenMoreData(b))
        .then((c) => {
            console.log("最终结果:", c);
            return c;
        })
        .catch((error) => {
            console.error("任何步骤的错误:", error);
        });
}
```

## 并行处理

同时执行多个异步操作：

```javascript
// Promise.all - 所有操作都成功才返回
async function fetchAllData() {
    try {
        const [users, posts, comments] = await Promise.all([
            fetch("/api/users").then((res) => res.json()),
            fetch("/api/posts").then((res) => res.json()),
            fetch("/api/comments").then((res) => res.json()),
        ]);

        return { users, posts, comments };
    } catch (error) {
        console.error("某个请求失败:", error);
    }
}

// Promise.allSettled - 等待所有操作完成，无论成功失败
async function fetchAllDataSettled() {
    const results = await Promise.allSettled([
        fetch("/api/users"),
        fetch("/api/posts"),
        fetch("/api/comments"),
    ]);

    results.forEach((result, index) => {
        if (result.status === "fulfilled") {
            console.log(`请求 ${index} 成功:`, result.value);
        } else {
            console.log(`请求 ${index} 失败:`, result.reason);
        }
    });
}

// Promise.race - 返回最先完成的操作
async function fetchWithTimeout() {
    const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error("请求超时")), 5000);
    });

    try {
        const result = await Promise.race([fetch("/api/data"), timeoutPromise]);
        return result;
    } catch (error) {
        console.error("请求失败或超时:", error);
    }
}
```

## async/await 语法

更直观的异步代码写法：

```javascript
// 基本用法
async function fetchUserData(userId) {
    try {
        const response = await fetch(`/api/users/${userId}`);

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const userData = await response.json();
        return userData;
    } catch (error) {
        console.error("获取用户数据失败:", error);
        throw error;
    }
}

// 顺序执行 vs 并行执行
async function sequentialExecution() {
    console.time("顺序执行");

    const user1 = await fetchUserData(1);
    const user2 = await fetchUserData(2);
    const user3 = await fetchUserData(3);

    console.timeEnd("顺序执行");
    return [user1, user2, user3];
}

async function parallelExecution() {
    console.time("并行执行");

    const [user1, user2, user3] = await Promise.all([
        fetchUserData(1),
        fetchUserData(2),
        fetchUserData(3),
    ]);

    console.timeEnd("并行执行");
    return [user1, user2, user3];
}
```

## 错误处理

异步操作的错误处理策略：

```javascript
// try-catch 处理单个异步操作
async function handleSingleOperation() {
    try {
        const data = await fetchData();
        return processData(data);
    } catch (error) {
        if (error instanceof NetworkError) {
            // 网络错误的特殊处理
            return retryOperation();
        } else if (error instanceof ValidationError) {
            // 验证错误的处理
            return getDefaultData();
        } else {
            // 其他错误
            console.error("未知错误:", error);
            throw error;
        }
    }
}

// 包装器函数统一错误处理
function createAsyncWrapper(asyncFn) {
    return async function (...args) {
        try {
            return await asyncFn.apply(this, args);
        } catch (error) {
            // 统一错误日志
            console.error(`函数 ${asyncFn.name} 执行失败:`, error);

            // 错误上报
            reportError(error);

            throw error;
        }
    };
}

// 使用包装器
const safeApiCall = createAsyncWrapper(async (url) => {
    const response = await fetch(url);
    return response.json();
});
```

## 实际应用场景

### 文件上传进度跟踪

```javascript
class FileUploader {
    async uploadWithProgress(file, onProgress) {
        return new Promise((resolve, reject) => {
            const formData = new FormData();
            formData.append("file", file);

            const xhr = new XMLHttpRequest();

            xhr.upload.addEventListener("progress", (event) => {
                if (event.lengthComputable) {
                    const progress = (event.loaded / event.total) * 100;
                    onProgress(progress);
                }
            });

            xhr.addEventListener("load", () => {
                if (xhr.status === 200) {
                    resolve(JSON.parse(xhr.responseText));
                } else {
                    reject(new Error(`上传失败: ${xhr.status}`));
                }
            });

            xhr.addEventListener("error", () => {
                reject(new Error("网络错误"));
            });

            xhr.open("POST", "/api/upload");
            xhr.send(formData);
        });
    }

    async uploadFile(file) {
        try {
            const result = await this.uploadWithProgress(file, (progress) => {
                console.log(`上传进度: ${progress.toFixed(2)}%`);
            });

            console.log("上传成功:", result);
            return result;
        } catch (error) {
            console.error("上传失败:", error);
            throw error;
        }
    }
}
```

### 数据缓存和重试机制

```javascript
class ApiCache {
    constructor() {
        this.cache = new Map();
        this.retryCount = 3;
        this.retryDelay = 1000;
    }

    async fetchWithCache(url, options = {}) {
        // 检查缓存
        if (this.cache.has(url)) {
            const cached = this.cache.get(url);
            if (Date.now() - cached.timestamp < 300000) {
                // 5分钟缓存
                return cached.data;
            }
        }

        // 带重试的请求
        const data = await this.fetchWithRetry(url, options);

        // 更新缓存
        this.cache.set(url, {
            data,
            timestamp: Date.now(),
        });

        return data;
    }

    async fetchWithRetry(url, options, attempt = 1) {
        try {
            const response = await fetch(url, options);

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }

            return await response.json();
        } catch (error) {
            if (attempt < this.retryCount) {
                console.log(
                    `请求失败，${this.retryDelay}ms 后重试 (${attempt}/${this.retryCount})`
                );

                await this.delay(this.retryDelay);
                return this.fetchWithRetry(url, options, attempt + 1);
            } else {
                throw error;
            }
        }
    }

    delay(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
    }
}
```

## 最佳实践

1. **优先使用 async/await** - 代码更易读
2. **适当的错误处理** - 不要忽略错误
3. **避免过度嵌套** - 使用 Promise 链或 async/await
4. **合理使用并行处理** - 提高性能
5. **设置超时机制** - 避免无限等待

## 常见陷阱

```javascript
// ❌ 错误：在循环中使用 await
async function badLoop() {
    const urls = ["/api/1", "/api/2", "/api/3"];
    const results = [];

    for (const url of urls) {
        const result = await fetch(url); // 顺序执行，很慢
        results.push(result);
    }

    return results;
}

// ✅ 正确：并行处理
async function goodLoop() {
    const urls = ["/api/1", "/api/2", "/api/3"];

    const results = await Promise.all(urls.map((url) => fetch(url)));

    return results;
}

// ❌ 错误：忘记 await
async function forgotAwait() {
    const data = fetchData(); // 返回 Promise，不是实际数据
    return data.name; // 错误！
}

// ✅ 正确：使用 await
async function rememberedAwait() {
    const data = await fetchData();
    return data.name;
}
```

## 小结

掌握异步编程的关键点：

1. **Promise 基础** - 理解 Promise 的状态和用法
2. **async/await** - 现代异步编程语法
3. **错误处理** - 完善的错误处理机制
4. **并行 vs 顺序** - 根据需求选择执行方式
5. **最佳实践** - 避免常见陷阱

异步编程是 JavaScript 开发的必备技能，正确使用能大大提升应用性能和用户体验。
