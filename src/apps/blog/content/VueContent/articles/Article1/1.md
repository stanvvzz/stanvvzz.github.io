# 切分父瓦片为四个子瓦片的worker代码优化

> 应用场景：在地图软件中，当拉近视角的时候，加载子瓦片。这个时候子瓦片还没有请求回来的时候，为了避免空白，我们需要将父瓦片切分为四个子瓦片先行顶替。这样在四个子瓦片内容请求回来之后再替换掉顶替瓦片。改功能需要进行canvas操作，为了避免性能损失，采用在worker中进行处理。
> 

经过测算，原代码耗时从30ms至200ms不等。通信时间未计算，但是是传输base64，时间肯定不短。

> 性能问题点：
> 

| 问题点 | 详细解释 | 性能影响 |
| --- | --- | --- |
| 1. `await convertToBlob()` | `convertToBlob()` 是**异步 IO 操作**，会让主线程/worker等待磁盘写入（即使是内存blob也是模拟的磁盘流程）。 | 极大增加了处理耗时，容易变卡 |
| 2. `new FileReaderSync().readAsDataURL(blob)` | 把 Blob **同步**转成Base64字符串，非常重，而且**内存翻倍**（binary ➔ base64） | 大幅增加**CPU使用率** + **内存占用** |
| 3. childMap里存的是 base64 | base64 比原始图像数据**大了33%**，一次4张 tile 会占更多内存。 | 导致 worker ➔ 主线程 postMessage 传输慢，占用多 |
| 4. `imageBitmap` 没关闭 | 原始 `imageBitmap` 在处理完后**没有 .close()**，会一直占用 GPU 内存。 | GPU memory 泄漏，内存越来越大 |
| 5. 多次 OffscreenCanvas 创建销毁 | 每个 tile 都 `new OffscreenCanvas`，而不是复用同一个 | 多次分配 canvas 内存，GC压力大 |
| 6. postMessage 传了很多没必要的数据 | 把 `{ childMap, x, y, z, index, isReceiveNullImage, imageBitmap, uuidArray, layerUUID }` 全打包发回去了，包括原图 | postMessage开销巨大，本来只需要返回childMap |
| 7. 需用通过new Image来接收base64 | `ImageBitmap`可以直接绘制在Canvas上 | 增加了额外的性能消耗 |

> 升级重点
> 

新版本完全绕开了 Blob/Base64，充分利用了浏览器底层对 ImageBitmap 的加速通道，整个 tile 分割 ➔ 传输 ➔ 渲染 全流程都大幅提速。而且在绘制阶段不需要通过new Image来处理base64。ImageBitmap可以直接绘制在Canvas上

> 参考文献
> 

[https://developer.chrome.com/blog/transferable-objects-lightning-fast?hl=zh-cn](https://developer.chrome.com/blog/transferable-objects-lightning-fast?hl=zh-cn)

原代码

```jsx
function getTileSplitingWorker(callback) {
	// worker_getTileSplitingWorker.js
	let workerCode = onmessage = async (event) => {
    const { imageBitmap, x, y, z, index, uuidArray,layerUUID } = event.data;

    const childMap = [[], []];
    let isReceiveNullImage = false;

    if(!imageBitmap) {
        isReceiveNullImage = true;
    }
    else {
        const tileWidth = imageBitmap.width / 2;
        const tileHeight = imageBitmap.height / 2;

        const targetImgSize = 128;

        for (let x = 0; x < 2; x++) {
            for (let y = 0; y < 2; y++) {
                // Create an OffscreenCanvas for each tile
                const offscreenCanvas = new OffscreenCanvas(targetImgSize, targetImgSize);
                // offscreenCanvas.width = targetImgSize;
                // offscreenCanvas.height = targetImgSize;
                const ctx = offscreenCanvas.getContext('2d');

                ctx.drawImage(
                    imageBitmap,
                    x * tileWidth, y * tileHeight, tileWidth, tileHeight, // Source rectangle
                    0, 0, targetImgSize, targetImgSize // Destination rectangle
                );

                // Convert the OffscreenCanvas to a Blob
                let tileURL = 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEAAAAALAAAAAABAAEAAAI=';

                if(tileWidth>1 && tileHeight>1) {
                    const blob = await offscreenCanvas.convertToBlob();
                    const tileBlob = URL.createObjectURL(blob);
                    tileURL = new FileReaderSync().readAsDataURL(blob);
                    // tileURL = URL.createObjectURL(blob);
                }
                else {
                    isReceiveNullImage = true;
                }

				                childMap[x][y] = tileURL;
            }
        }
    }

		postMessage({ childMap, x, y, z, index, isReceiveNullImage, imageBitmap, uuidArray,layerUUID });
}

	const blob = new Blob([workerCode], { type: "application/javascript" })
	const workerURL = URL.createObjectURL(blob)
	const worker = new Worker(workerURL)

	worker.onmessage = function (event) {
		callback(event.data)
	}

	return worker
}
```

升级代码

```jsx
function getTileSplitingWorker(callback) {
	let workerCode = `
        self.onmessage = async (event) => {
            const startTime = performance.now();
            const { imageBitmap, x, y, z, index, uuidArray, layerUUID } = event.data;
            const width = imageBitmap.width;
            const height = imageBitmap.height;

            // 将图像分为2X2,动态计算每块的大小
            const halfWidth = Math.ceil(width / 2);
            const halfHeight = Math.ceil(height / 2);

            const result = [[], []];

            let isReceiveNullImage = false;

            if (!imageBitmap) {
                isReceiveNullImage = true;
            } else {
                for (let col = 0; col < 2; col++) {
                    for (let row = 0; row < 2; row++) {
                        const sx = col * halfWidth;
                        const sy = row * halfHeight;
                        const sw = Math.min(halfWidth, width - sx);
                        const sh = Math.min(halfHeight, height - sy);

                        const smallBitmap = await createImageBitmap(
                            imageBitmap, sx, sy, sw, sh,
                            { resizeWidth: 128, resizeHeight: 128, resizeQuality: 'high' }
                        );
                        result[col][row] = smallBitmap;
                    }
                }
            }

            // 将结果ImageBitmap列表和childMap一起转移回主线程(避免复制)
            postMessage({ childMap: result, x, y, z, index, isReceiveNullImage, uuidArray, layerUUID, imageBitmap }, result.flat());
        }
    `

	const blob = new Blob([workerCode], { type: "application/javascript" })
	const workerURL = URL.createObjectURL(blob)
	const worker = new Worker(workerURL)

	worker.onmessage = function (event) {
		callback(event.data)
	}

	return worker
}

export default getTileSplitingWorker

```